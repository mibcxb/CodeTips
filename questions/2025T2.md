# 2025 题库（阶段二）

## 1、 教授分组

有 n 个人，进行分组，分组模式有三种：

1. 三人一组，要求最高分和最低分相差不超过 10 分；
2. 二人一组，要求两个人相差不超过 20 分；
3. 一人一组，分数没有要求；

求最少可以分几组。

解答：

```java
    public static int minGroups(int[] scores) {
        Arrays.sort(scores);
        int groups = 0;
        int n = scores.length;
        int l = 0, r;
        while (l < scores.length) {
            r = l + 2; // 先尝试三人一组
            if (r < n && scores[r] - scores[l] <= 10) {
                l = r + 1; // 符合要求，跳过这三个分数
            } else {
                r = l + 1; // 再尝试二人一组
                if (r < n && scores[r] - scores[l] <= 20) {
                    l = r + 1; // 符合要求，跳过这二个分数
                } else {
                    l = r; // 单人成组
                }
            }
            groups++; // 增加组数
        }
        return groups;
    }
```

## 2、 小红的红黑数

小红有一个整数数组，给出一个包含'R'和'B'的字符串，字符串第 i 位上的'R'或'B'标识数组中第 i 个数字为红数或黑数，将一个红数和一个黑数相乘为一个红黑数，求全部红黑数之和，结果对 1000000007 取模。

解答：

```java
    private static final int MOD = 1000000007;

    public static int calcRedBlackSum(int[] nums, String colors) {
        long redSum = 0;
        long blackSum = 0;

        for (int i = 0; i < nums.length; i++) {
            if (colors.charAt(i) == 'R') {
                redSum = (redSum + nums[i]) % MOD;
            } else {
                blackSum = (blackSum + nums[i]) % MOD;
            }
        }

        long result = (redSum * blackSum) % MOD;
        return (int) ((result + MOD) % MOD);  // 确保结果为非负数
    }
```

## 3、 相似三角形

给定一个三角形（a,b,c 表示三条边长），然后输入三个数字 x,y,z，判断 x,y,z 是否是三角形，如果不是，输出一行“不是”的字符串，如果是三角形，判断和给定的三角形 a,b,c 是否相似，如果相似，输出“相似”的字符串，否则输出“不相似”的字符串。

解答：

```java
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        double[] triangle1 = new double[3];
        double[] triangle2 = new double[3];
        for (int i = 0; i < 3; i++) {
            triangle1[i] = scanner.nextDouble();
        }
        for (int i = 0; i < 3; i++) {
            triangle2[i] = scanner.nextDouble();
        }

        if (!isTriangle(triangle1)) {
            System.out.println("第一个三角形不合法，不是三角形");
        } else if (!isSimilar(triangle1, triangle2)) {
            System.out.println("两个三角形不相似");
        } else {
            System.out.println("两个三角形是相似三角形");
        }
    }

    // 判断三边能否组成三角形
    public static boolean isTriangle(double[] sides) {
        return sides[0] + sides[1] > sides[2] &&
                sides[0] + sides[2] > sides[1] &&
                sides[1] + sides[2] > sides[0];
    }

    // 判断两个三角形是否相似（对应边成比例）
    public static boolean isSimilar(double[] triangle1, double[] triangle2) {
        double ratio1 = triangle1[0] / triangle2[0];
        double ratio2 = triangle1[1] / triangle2[1];
        double ratio3 = triangle1[2] / triangle2[2];
        // 使用一个精度范围判断比例是否相等（避免浮点误差）
        return Math.abs(ratio1 - ratio2) < 1e-9 && Math.abs(ratio2 - ratio3) < 1e-9;
    }
```

## 4、 最多可以分解为多少个质数

给定一个正整数 n，求 n 最多可以分解为多少个质数之和。如：5=2+3，输出 2。

**思路**

- 最小的偶数质数为 2；
- 最小的奇数质数为 3；
- 所有的正整数都可以分解为：2+2+...+2+(2+1) 的形式。

解答：

```java
    public static int countPrimeFactors(int n) {
        retuen n / 2;
    }
```

## 5、 给学生发短信

给定 n 个学生，m 门课程，老师要给超过超过课程平均分的同学发祝贺短信，求最少需要多少条短信。

解答：

```java
    public static int minMessageCount(int[][] scores) {
        int students = scores.length;
        if (students == 0) return 0;
        int courses = scores[0].length;

        double[] courseAverages = new double[courses];
        for (int c = 0; c < courses; c++) {
            double sum = 0;
            for (int[] score : scores) {
                sum += score[c];
            }
            courseAverages[c] = sum / students;
        }

        int count = 0;
        for (int s = 0; s < students; s++) {
            boolean flag = false;
            for (int c = 0; c < courses; c++) {
                if (scores[s][c] > courseAverages[c]) {
                    flag = true;
                    break;
                }
            }
            if (flag) {
                count++;
            }
        }
        return count;
    }
```

## 6、 K 次交换位置

给一个长度为 n 的数组 arr，元素为 ai，共遍历 m 次，k in [1, m]，当满足 arr[i] % k > arr[i + 1] % k 时，交换元素位置。输出遍历 K 次后的数组。

解答：

```java
    public static int[] swapNumbers(int[] arr, int m) {
        for (int k = 1; k <= m; k++) {
            for (int i = 0; i < arr.length - 1; i++) {
                if (arr[i] % k > arr[i + 1] % k) {
                    int temp = arr[i];
                    arr[i] = arr[i + 1];
                    arr[i + 1] = temp;
                }
            }
        }
        return arr;
    }
```

## 7、 非 1 元素的公约数

给定一个数组，求数组中非 1 元素的最小公约数。

**思路**

1. 先计算数组中所有非 1 元素的最大公约数；
2. 如果 GCD 为 1，则没有非 1 公约数；
3. 找出 GCD 中最小的非 1 质因数。

解答：

```java
    public static int gcd(int a, int b) {
        if (b == 0) return a;
        return gcd(b, a % b);
    }

    public static int gcdExOne(int[] nums) {
        // 先过滤出非1元素
        int[] filtered = Arrays.stream(nums).filter(x -> x != 1).toArray();
        if (filtered.length == 0) return 1;
        // 计算最大公约数GCD
        int result = filtered[0];
        for (int i = 1; i < filtered.length; i++) {
            result = gcd(result, filtered[i]);
            if (result == 1) {
                break;
            }
        }
        if (result == 1) return -1;
        // 找出最小质因数
        for (int i = 2; i * i <= result; i++) {
            if (result % i == 0) return i;
        }
        return result;
    }
```

## 8、 通过异或和找出丢失的数

给定一个 sum 为 1~n 的异或和，但在求和过程中少了一个数（如：n=5，sum=1^2^4^5），求出缺失的数。

**思路**

用到异或运算的重要性质：

1. 交换律与结合律 ‌。这使得异或运算的顺序不影响最终结果。‌‌

```
交换律：a ⊕ b = b ⊕ a。
结合律：a ⊕ (b ⊕ c) = (a ⊕ b) ⊕ c。
```

2. 恒等律与归零律 ‌。

```
恒等律：a ⊕ 0 = a（任何数与0异或结果不变）。
归零律：a ⊕ a = 0（任何数与自身异或结果为0）。‌‌
```

3. ‌ 自反性与可逆性 ‌。

```
自反性：a ⊕ b ⊕ b = a（连续两次异或同一数可还原原值）。
推论：若 a ⊕ b = c，则 a ⊕ c = b 且 b ⊕ c = a。‌‌
```

4. ‌ 分配律（与 AND 运算结合）‌。

```
a & (b ⊕ c) = (a & b) ⊕ (a & c)。‌‌
```

本题主要使用的是可逆性的推论。

解答：

```java
    public static int findMissingNum(int n, int xorSum) {
        int curSum = 0;
        for (int k = 1; k <= n; k++) {
            curSum ^= k;
        }
        return curSum ^ xorSum;
    }
```

## 9、 左侧有几个不同的值

给定一个 01 串，遍历这个字符串，输出当前下标左侧有多少个不同的数值。

示例：

```
输入：01101
输出：01222
```

解答：

```java
    public static String countNum(String source) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < source.length(); i++) {
            Set<Character> set = new HashSet<>();
            for (int j = 0; j < i; j++) {
                set.add(source.charAt(j));
            }
            sb.append(set.size());
        }
        return sb.toString();
    }
```

## 10、 可调顺序极差和

给定长度为 n 的整数，可调整各位上数字的顺序，如：154937→134579，求各位之间的差值和的最大值。如：(9-1)+(7-3)+(5-4)

解答：

```java
    public static int maxSum(int n) {
        char[] digits = String.valueOf(n).toCharArray();
        Arrays.sort(digits);

        int l = 0;
        int r = digits.length - 1;
        int sum = 0;
        while (l < r) {
            sum = digits[r] - digits[l];
            l++;
            r--;
        }
        return sum;
    }
```

## 11、 鸵鸟吃东西

输入一个数组 arr，数组中的元素表示食物的高度；输入一个值 h，表示鸵鸟的高度；鸵鸟只能吃到高度小于等于它身高的食物，鸵鸟每吃一个食物身高+1；求鸵鸟最终的身高。

解答：

```java
    public static int ostrichHeight(int[] arr, int h) {
        Arrays.sort(arr);
        int height = h;
        for (int i : arr) {
            if (i <= height) {
                height++;
            }
        }
        return height;
    }
```

## 12、 相邻字母最长串

给一个字符串，如果两个原字母表中相邻字母，在这个串里也相邻，则为好串，求这个串里最长好串长度。

解答：

```java
    public static int maxLen(String s) {
        if (s == null || s.isEmpty()) return 0;
        int maxLen = 1;
        int curLen = 1;
        char[] chars = s.toCharArray();
        for (int i = 1; i < chars.length; i++) {
            if (Math.abs(chars[i] - chars[i - 1]) == 1) {
                curLen++;
                maxLen = Math.max(curLen, maxLen);
            } else {
                curLen = 1;
            }
        }
        return maxLen;
    }
```

## 13、 变换字符串最小代价

输入一个字符串，变化规则如下：

1. 同为大写字母可以变换，如：A→B；
2. 同为小写字母可以变换，如：a→b；
3. 字母大小写可以变换，如：A→a；

每次变换的代价为 5，求字符串中包含“AcMer”的最小代价。

解答：

```java
    public static int minCost(String s, String t) {
        int n = s.length();
        if (n < t.length()) return -1;

        int minCost = Integer.MAX_VALUE;
        int curCost;
        char cs, ct;
        for (int i = 0; i <= n - t.length(); i++) {
            curCost = 0;
            for (int j = 0; j < t.length(); j++) {
                cs = s.charAt(i + j);
                ct = t.charAt(j);
                // 如果忽略大小写相同
                if (Character.toLowerCase(cs) == Character.toLowerCase(ct)) {
                    if (cs != ct) {
                        curCost += 5; // 仅大小写不同，需要转换
                    }
                } else {
                    curCost += 5; // 完全不同字符，需要替换
                }
            }
            minCost = Math.min(curCost, minCost);
        }
        return minCost;
    }
```

## 14、 僵尸数组

给定一个二维数组，其中元素不为 0，且可以相互连接起来的称为一堆僵尸，一个数单独的也可称为一堆，求一共有多少堆僵尸。

解答：

```java
    public static int clusterZombies(int[][] source) {
        if (source == null || source.length == 0 || source[0].length == 0) {
            return 0;
        }
        int count = 0;
        int rows = source.length;
        int cols = source[0].length;
        for (int row = 0; row < rows; row++) {
            for (int col = 0; col < cols; col++) {
                if (source[row][col] == 1) { // 发现未访问的非零元素
                    count++; // 增加区域计数
                    dfs(source, row, col); // 标记相邻区域
                }
            }
        }
        return count;
    }

    public static void dfs(int[][] grid, int i, int j) {
        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length) {
            return; // 边界检测
        }
        if (grid[i][j] == 0) {
            return; // 没有僵尸
        }
        grid[i][j] = 0; // 标记已访问元素
        // 递归检查四周
        dfs(grid, i + 1, j); // 下
        dfs(grid, i - 1, j); // 上
        dfs(grid, i, j + 1); // 右
        dfs(grid, i, j - 1); // 左
    }
```

## 15、 小红串

给定一个全部为小写字符的字符串，如果这个字符串中所有的字符左右都是字母表中相邻的字符，则这个字符串可以被称为小红串， 比如 babc 是小红串，red 不是小红串。现在给出一个全部为小写字符的字符串，尽可能少的移除其中的字符，使字符串符合小红串的定义，求最终所能达到的最长的小红串的长度。例：baab ，当移除一个 a 时，符合小红串定义，最长为 3。

解答：

```java
    public static int longestRedString(String s) {
        if (s == null || s.isEmpty()) {
            return 0;
        }
        int[] dp = new int[s.length()];
        Arrays.fill(dp, 1);
        int maxLen = 1;
        for (int i = 1; i < s.length(); i++) {
            for (int j = 0; j < i; j++) {
                if (Math.abs(s.charAt(i) - s.charAt(j)) == 1) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            maxLen = Math.max(dp[i], maxLen);
        }
        return maxLen;
    }
```

## 16、 绘制“里”字

一个正整数 n，代表里字的大小（1<=n<=30）；输出一个 11*n 行，每行长度为 11*n 列，仅包含“.”和“\*”的字符串，这些字符串从视觉上组成“里”字。

示例：

```
输入：n = 1
> ...........
> ..*******..
> ..*..*..*..
> ..*******..
> ..*..*..*..
> ..*******..
> .....*.....
> ..*******..
> .....*.....
> .*********.
> ...........
```

```
输入：n = 2
> ......................
> ......................
> ....**************....
> ....**************....
> ....**....**....**....
> ....**....**....**....
> ....**************....
> ....**************....
> ....**....**....**....
> ....**....**....**....
> ....**************....
> ....**************....
> ..........**..........
> ..........**..........
> ....**************....
> ....**************....
> ..........**..........
> ..........**..........
> ..******************..
> ..******************..
> ......................
> ......................
```

解答：

```java
    public static void drawLi(int n) {
        int size = 11 * n;
        String dots = ".".repeat(size);
        String starLine = ".".repeat(2 * n) + "*".repeat(7 * n) + ".".repeat(2 * n);
        String dash3Str = ".".repeat(2 * n) + "*".repeat(n) + ".".repeat(2 * n) + "*".repeat(n) + ".".repeat(2 * n) + "*".repeat(n) + ".".repeat(2 * n);
        String dash1Str = ".".repeat(5 * n) + "*".repeat(n) + ".".repeat(5 * n);
        String lastLine = ".".repeat(n) + "*".repeat(9 * n) + ".".repeat(n);
        int j;
        for (int i = 0; i < size; i++) {
            j = i / n % 11;
            if (j == 9) {
                System.out.println(lastLine);
            } else if (j == 1 || j == 3 || j == 5 || j == 7) {
                System.out.println(starLine);
            } else if (j == 2 || j == 4) {
                System.out.println(dash3Str);
            } else if (j == 6 || j == 8) {
                System.out.println(dash1Str);
            } else {
                System.out.println(dots);
            }
        }
    }
```
