# 2025 题库（阶段三）

## 01、 非递减数组

给定一个长度为 n 的数组，每次只能对其中的一个元素进行加 1 操作，最少可以通过多少次操作使其变成非递减的数组。非递减数组：a1 ≤ a2 ≤ ... ≤ an。

解答：

```java
    public static int makeNonDecreasing(int[] arr) {
        if (arr.length < 2) {
            return 0;
        }
        int count = 0;
        int prev = arr[0];
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] < prev) {
                count += prev - arr[i];
            } else {
                prev = arr[i];
            }
        }
        return count;
    }
```

## 02、 满二叉树编号（LCA）

给定无穷大满二叉树，从其根节点开始，一层一层的从左向右依次编号，根节点编号为 1，求 a b 两个节点的最近公共祖先的编号。

思路：

在按层从左到右编号（堆式编号，根为 1）的无限满二叉树中，任意节点 x 的父节点是 x/2。因此，两个节点 a,b 的最近公共祖先（LCA）可以通过不断把较大的那个节点上移到其父节点，直到二者相等为止。

- 父节点关系：parent(x) = x / 2（整数除法）
- 终止条件：当 a == b 时，该值即为 LCA

时间复杂度：O(logmax(a,b))，空间复杂度：O(1)

解答：

```java
    public static long lca(int a, int b) {
        if (a <= 0 || b <= 0) {
            return -1;
        }
        while (a != b) {
            if (a > b) {
                a >>= 1;
            } else {
                b >>= 1;
            }
        }
        return a;
    }
```

## 03、 好数组

一个组数，定义好数组的规则为不同元素的个数与数组的长度相等。比如{1,2,3}是好数组，{1,1,2,3}不是，但{}是好数组。

给定一个数组，每次可以删除任意 k 个元素，但删除前需要满足当前数组的长度大于等于 k，可以执行 0 次或任意次，如果能得到好数组输出 yes，否则输出 no。

示例：

测试数据组数 2，初始数组元素个数 5,4，k 值为 3,2，输出 no，yes

```
输入：
2
5 3
1 1 1 1 1
4 2
1 2 3 4
输出：
no
yes
```

思路：数组长度对 k 取余的值 `小于等于` 数组去重后的长度就是好数组。

解答：

```java
    public static void isGoodNumArr(int[] arr, int k) {
        int[] distinct = Arrays.stream(arr).distinct().toArray();
        boolean flag = arr.length % k <= distinct.length;
        System.out.println(flag ? "yes" : "no");
    }
```

## 04、 未出现字符值的和

给定一个全部由大写字母 A~Z 组成的字符串，找出未出现的字符，计算这些字符 ASCII 码的和。

```java
    public static int asciiSum(String s) {
        int[] marks = new int[26];
        Arrays.fill(marks, 0);
        for (char c : s.toCharArray()) {
            if ('A' <= c && c <= 'Z') {
                marks[c - 'A'] = 1;
            }
        }
        int sum = 0;
        for (int i = 0; i < marks.length; i++) {
            if (marks[i] == 0) {
                sum += 'A' + i;
            }
        }
        return sum;
    }
```

## 05、 数组整除

给定一个数字 num，依次判断这个数字是否可以被各个数位上的数字整除，统计能整除 num 的数位的个数。

```java
    public static int countDivisibility(int num) {
        int count = 0;
        int n = num;
        int d;
        while (n != 0) {
            d = n % 10;
            if (num % d == 0) {
                count++;
            }
            n /= 10;
        }
        return count;
    }
```

## 06、 满足条件的数字对

给定两个数 A 和 B，且有 0 ≤ x ≤ y ≤ 2^31-1

- x <= y
- x & y = A
- x | y = B

计算有多少对 x, y 满足以上条件。

思路：

- 若存在某一位使得 A 为 1 而 B 为 0，则不可能满足（因为该位既要求两数都是 1，又要求至少一个是 0），即：
  - 若 (A \& ~B) ≠ 0，答案为 0。
- 除去非法情况后，对于每一位：
  - 若 Ai=1，则两数该位固定为 1；
  - 若 Bi=0，则两数该位固定为 0（此时 Ai 必为 0）；
  - 若 Ai=0, Bi=1，则该位两数必须一 0 一 1，有两种分配：(0,1) 或 (1,0)。
- 设“自由位”数 k = bitcount(A ⊕ B)（在合法情况下即为 B 是 1 而 A 是 0 的位数）。
  - 若不考虑 x ≤ y，每个自由位 2 种分配，总计 2^k 个有序对。
  - 加上 x ≤ y：
    - 若 k=0，唯一解为 x=y=A，答案 1。
    - 若 k>0，不存在 x=y（至少有一位不同），且通过“交换所有自由位上 x、y 的取值”可成双成对地构造大小相反的一一对应，因此恰好一半满足 x<y。答案为 2^k-1。

同时还需保证 A、B 都在 [0, 2^31−1]，否则无解（因为 x、y 只能到 2^31−1，其按位或不可能产生第 31 位为 1）。

位运算的计算性质，x ⊕ y = (x | y) - (x & y) = B - A。

解答：

```java
    public static long numberPairCount(long a, long b) {
        final long limit = 1L << 31; // 2^31
        // 范围检查：x,y <= 2^(31-1) -> A,B 也必须在此范围内且非负
        if (a < 0 || b < 0 || a >= limit || b >= limit) {
            return 0;
        }
        // 合法性检查：A 的 1 位不能出现在 B 的 0 位上
        if ((a & ~b) != 0) {
            return 0;
        }
        // 自由位个数：A 与 B 不同的位（在合法时即 A=0,B=1 的位）
        int k = Long.bitCount(a ^ b);
        // k=0 => x=y=A，唯一解；k>0 -> 2^(k-1)
        return k == 0 ? 1L : 1L << (k - 1);
    }
```

## 07、 树节点染色

一棵有 n 个节点的树，根节点为 1 号节点，给树的一部分节点染成红色，然后有 q 次询间，每次询问需要给出某点的子树中红色节点的数量。

示例：

```
输入4个整数代表2~5号节点的父节点
1 2 1 4
输入长度为5的"W"和"R"组成的字符串，W表示不染色，R表示红色
WWRRR
则树的样子为

      1W
      /\
    2W  4R
   /      \
 3R        5R

q为3，表示询问3次
询问3号节点的子树中红色节点的数量，返回1
询问1号节点的子树中红色节点的数量，返回3
询问4号节点的子树中红色节点的数量，返回2
```

解答：

```java
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        // 节点2~n的父节点编号
        int[] parents = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();
        // 节点数量（包含根节点1
        int n = parents.length + 1;
        // 树的邻接表表示
        List<List<Integer>> tree = new ArrayList<>();
        for (int i = 0; i <= n; i++) { // 这里使用 i <= n 是因为节点从1开始编号，多一个可以避免越界
            tree.add(new ArrayList<>());
        }
        for (int i = 0; i < parents.length; i++) {
            int number = i + 2; // 节点编号从2开始
            int parent = parents[i];
            tree.get(parent).add(number);
        }
        // 读取染色字符串
        String colorStr = sc.nextLine().trim();
        int[] colors = new int[colorStr.length() + 1]; // 同样为了避免越界
        for (int i = 1; i <= colorStr.length(); i++) {
            colors[i] = colorStr.charAt(i - 1) == 'R' ? 1 : 0;
        }
        // 创建答案数组并进行DFS计算
        int[] counts = new int[colors.length];
        dfs(1, tree, colors, counts);
        // 处理查询
        int q = sc.nextInt();
        while (q-- > 0) {
            System.out.println(counts[sc.nextInt()]);
        }
    }

    private static void dfs(int i, List<List<Integer>> tree, int[] colors, int[] counts) {
        int total = colors[i]; // 当前节点的红色状态
        for (int child : tree.get(i)) {
            dfs(child, tree, colors, counts); // 递归处理子节点
            total += counts[child]; // 累加子树的红色节点数量
        }
        counts[i] = total;
    }
```

## 08、 最长合法前缀

一个全部由'('和')'组成的字符串，求该字符串的最长合法前缀，合法前缀定义为：()，(()) 都合法，而 )() 不合法。

解答：

```java
    public static int longestLength(String s) {
        int balance = 0;
        int best = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') {
                balance++;
            } else {
                balance--;
            }
            if (balance < 0) {
                break;
            }
            if (balance == 0) {
                best = i + 1;
            }
        }
        return best;
    }
```

## 09、去除字符

给定一个字符串 s，例如 2012，或 2012+2013+2015-2019+2020，其中的符号只有加减号，目前只去掉一个字符，例如 2012 去掉 0 得到 212，保证去掉一个字符后，得到的结果最大，输出这个结果。

```java
    public static void removeOneChar(String str) {
        long max = Long.MIN_VALUE;
        for (int i = 0; i < str.length(); i++) {
            String s = str.substring(0, i) + str.substring(i + 1);
            max = Math.max(max, calc(s));
        }
        System.out.println(max);
    }

    public static long calc(String s) {
        if (s.isEmpty()) {
            return 0;
        }
        long result = 0;
        String[] pArr = s.split("\\+");
        String[] mArr;
        String text;
        long parsed;
        for (String pStr : pArr) {
            if (pStr.isEmpty()) {
                continue;
            }
            mArr = pStr.split("-");
            for (int j = 0; j < mArr.length; j++) {
                text = mArr[j];
                parsed = text.isEmpty() ? 0 : Long.parseLong(text);
                if (j == 0) {
                    result += parsed;
                } else {
                    result -= parsed;
                }
            }
        }
        return result;
    }
```

## 10、 函数求和

给出函数 f(x)，如 f(12)=f(0b1100)=4(0b100)，f(4)=f(0b100)=4(0b100)，f(1)=f(0b1)=1，即 f(x)的输出是 x 的二进制表示从右往左数出现第一个 1 的二进制大小。

输入整数 N，求 1/f(1)+2/f(2)+i/f(i)+...+f(N)

解答：

```java
    public static long sum(long n) {
        long sum = 0;
        for (long i = 1; i <= n; i++) {
            sum += i / lsb(i);
        }
        return sum;
    }

    /**
     * Last Set Bit
     */
    public static long lsb(long x) {
        return x & (-x);
    }
```

## 11、 牛牛太空人

牛有一艘太空飞船，牛牛想驾驶太空飞船飞出大气层，当前飞船的坐标是（x,y,z），速度向量是（vx,vy,vz），将大气层看做一个半径为 r 的球体，问什么时刻 t 飞船能到达大气层边缘（要求精度不低于 1\*10^(-5)）。

```java
    public static void timeToSphere(double x, double y, double z, double vx, double vy, double vz, double r) {
        double a = vx * vx + vy * vy + vz * vz;
        double b = 2 * (vx * x + vy * y + vz * z);
        double c = x * x + y * y + z * z - r * r;
        double delta = b * b - 4 * a * c;
        double result;
        if (delta < 0) {
            result = 0;
        } else if (delta == 0) {
            result = -b / 2 * a;
        } else {
            double t1 = (-b + Math.sqrt(delta)) / (2 * a);
            double t2 = (-b - Math.sqrt(delta)) / (2 * a);
            if (t1 > 0 && t2 > 0) {
                result = Math.min(t1, t2);
            } else if (t1 > 0) {
                result = t1;
            } else if (t2 > 0) {
                result = t2;
            } else {
                result = 0;
            }
        }
        System.out.printf("%.5f", result);
    }
```

## 12、 牛牛切割数

牛牛有一个数字 n，可以对 n 进行切割，把切割后的数字相加得到结果，问有几种不同的结果。

示例：

```
输入：123

情况1：1,2,3，结果为6
情况2：12,3， 结果为15
情况3：1，23，结果为24
情况4：123，  结果为123

输出：4
```

解答：

```java
    public static int splitNum(String numStr) {
        int length = numStr.length();
        int size = 1 << (length - 1);
        Set<Integer> result = new HashSet<>();
        StringBuilder builder;
        for (int mark = 0; mark < size; mark++) {
            builder = new StringBuilder();
            for (int i = 0; i < length; i++) {
                builder.append(numStr.charAt(i));
                if (i < size && (mark >> i & 1) == 1) {
                    builder.append('+');
                }
            }
            int sum = Arrays.stream(builder.toString().split("\\+")).mapToInt(Integer::parseInt).sum();
            result.add(sum);
        }
        return result.size();
    }
```

## 13、 小红的区间数

小红拿到一个数组，取连续的一段区间，使区间中的数相乘不为 0，问这个区间的最大长度。

示例：

```
输入：1 0 2 3 5 0 1 1
输出：3
```

解答：

```java
    public static int maxLen(int[] arr) {
        int max = 0;
        int len = 0;
        for (int i : arr) {
            if (i == 0) {
                len = 0;
            } else {
                len++;
                max = Math.max(max, len);
            }
        }
        return max;
    }
```

## 14、 牛牛扔骰子

牛牛有一个骰子共 n 面，每面有一个数字（数字可重复），牛牛的第一个幸运数为 A，第二个幸运数为 B。牛牛可以扔两次骰子，求当且仅当第一次得到 A，第二次得到 B 的期望次数（输出保留 1 位小数）。

```
输入：
3 1 2 （即 n A B）
1 2 3 （n 面上的数）
输出：
9.0
```

解答：

```java
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int a = sc.nextInt();
        int b = sc.nextInt();
        int countA = 0;
        int countB = 0;
        int v;
        for (int i = 0; i < n; i++) {
            v = sc.nextInt();
            if (v == a) countA++;
            if (v == b) countB++;
        }
        double pA = (double) countA / (double) n;
        double pB = (double) countB / (double) n;
        double result = 1d / (pA * pB);
        System.out.printf("%.1f", result);
    }
```

## 15、 牛牛大胃王

牛牛的胃口为 m，给定一个数组 vec（数组长度为 n），里面存放了 n 个食物的所能补充的能量，问牛牛能不能吃饱。能吃饱输出“Yes”，否则输出“No”

解答：

```java
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        for (int i = 0; i < t; i++) {
            int n = sc.nextInt();
            int m = sc.nextInt();
            int sum = 0;
            for (int j = 0; j < n; j++) {
                sum += sc.nextInt();
            }
            if (sum >= m) {
                System.out.println("Yes");
            } else {
                System.out.println("No");
            }
        }
    }
```

## 16、 报数游戏

牛牛和牛妹玩游戏，牛牛喊 x，牛妹只能喊 x+1，x+2，x+3（比如牛牛喊 2，则牛妹只能喊 [3,4,5] 中的一个），两个人互相轮询，如果喊的数超过 n 则判输，开始的数字为 k（不能喊 k，至少 k+1），输入 n，牛牛先开始喊，如果要牛牛必胜，列举 k 值。

示例：

```
输入：6
输出：1 3 4 5
解释：
n = 6
k = 1 时，牛妹喊3 4 5，牛牛喊6必胜
k = 3 时，牛牛喊6必胜
```

解答：

```java
    public static void listNums(int n) {
        List<Integer> list = new ArrayList<>();
        for (int k = 1; k < n; k++) {
            if ((n - k) % 4 != 0) {
                list.add(k);
            }
        }
        for (int i = 0; i < list.size(); i++) {
            if (i > 0) System.out.print(" ");
            System.out.print(list.get(i));
        }
        System.out.println();
    }
```

## 17、 3 的倍数

一个由 0~9 组成的字符串，字符串长度 3~10^5，取任意个字符组成一个数，返回是 3 的倍数的最大值，如果没有返回-1。

要点：

```
一个数能否被 3 整除只取决于各位数字和对 3 的余数。

设各位数字和的余数为 m = sum mod 3
若 m = 0：全部保留，按降序排列即最大
若 m = 1：删除“总余数为 1”的最小代价：
  优先删 1 个最小的余 1 数字（1,4,7 中最小的）
  否则删 2 个最小的余 2 数字（2,5,8 中最小的两位）
若 m = 2：对称地处理：
  优先删 1 个最小的余 2 数字（2,5,8 中最小的）
  否则删 2 个最小的余 1 数字（1,4,7 中最小的两位）

删除后将剩余数字按降序拼接即为最大值
特殊处理：若最终只剩下若干个 0，答案应输出为 "0"；若一个数字也没有，输出 "-1"
```

解答：

```java
    public static String createMultiples3(String str) {
        int[] cnt = new int[10]; // 统计0-9在字符串中出现的次数
        long sum = 0;
        int num;
        for (char ch : str.toCharArray()) {
            num = ch - '0';
            cnt[num]++;
            sum += num;
        }

        int mod = (int) (sum % 3);
        if (mod == 1) {
            if (!removeNum(cnt, new int[]{1, 4, 7}, 1)) {
                if (!removeNum(cnt, new int[]{2, 5, 8}, 2)) {
                    return "-1";
                }
            }
        } else if (mod == 2) {
            if (!removeNum(cnt, new int[]{2, 5, 8}, 1)) {
                if (!removeNum(cnt, new int[]{1, 4, 7}, 2)) {
                    return "-1";
                }
            }
        }

        int total = 0;
        StringBuilder sb = new StringBuilder();
        for (int d = 9; d >= 0; d--) {
            total += cnt[d];
            for (int k = 0; k < cnt[d]; k++) {
                sb.append((char) ('0' + d));
            }
        }
        if (total == 0) {
            return "-1";
        }
        if (sb.charAt(0) == '0') { // 若全为 0，输出单个 "0"
            return "0";
        } else {
            return sb.toString();
        }
    }

    private static boolean removeNum(int[] cnt, int[] choices, int need) {
        for (int choice : choices) {
            while (need > 0 && cnt[choice] > 0) {
                cnt[choice]--;
                need--;
            }
            if (need == 0) return true;
        }
        return false;
    }
```
