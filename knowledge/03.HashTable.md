# 03.HashTable（哈希表）

## 0、 基础理论

哈希表是根据关键码的值而直接进行访问的数据结构。其中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素。一般哈希表都是用来快速判断一个元素是否出现集合里。

## 1、 有效的字母异位词

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。可以假设字符串只包含小写字母。

```
示例 1: 输入: s = "anagram", t = "nagaram" 输出: true
示例 2: 输入: s = "rat", t = "car" 输出: false
```

**思路**

定义一个数组叫做 record 用来上记录字符串 s 里字符出现的次数。

需要把字符映射到数组也就是哈希表的索引下标上，因为字符 a 到字符 z 的 ASCII 是 26 个连续的数值，所以字符 a 映射为下标 0，相应的字符 z 映射为下标 25。

再遍历 字符串 s 的时候，只需要将 s[i] - ‘a’ 所在的元素做+1 操作即可，并不需要记住字符 a 的 ASCII，只要求出一个相对数值就可以了。 这样就将字符串 s 中字符出现的次数，统计出来了。

那看一下如何检查字符串 t 中是否出现了这些字符，同样在遍历字符串 t 的时候，对 t 中出现的字符映射哈希表索引上的数值再做-1 的操作。

那么最后检查一下，record 数组如果有的元素不为零 0，说明字符串 s 和 t 一定是谁多了字符或者谁少了字符，return false。

最后如果 record 数组所有元素都为零 0，说明字符串 s 和 t 是字母异位词，return true。

```Java
    public boolean isAnagram(String s, String t) {
        int[] record = new int[26];
        // 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了
        for (int i = 0; i < s.length(); i++) {
            record[s.charAt(i) - 'a']++;
        }
        for (int i = 0; i < t.length(); i++) {
            record[t.charAt(i) - 'a']--;
        }
        for (int count : record) {
            if (count != 0) {
                // record数组如果有的元素不为零0，说明字符串s和t一定是谁多了字符或者谁少了字符。
                return false;
            }
        }
        return true; // record数组所有元素都为零0，说明字符串s和t是字母异位词
    }
```

## 2、 快乐数

编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。

如果 n 是快乐数就返回 True ；不是，则返回 False 。

示例：

```
输入：19
输出：true
解释：
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1
```

**思路**

题目中说了会 `无限循环`，那么也就是说求和的过程中，sum 会重复出现，这对解题很重要！使用哈希法，来判断这个 sum 是否重复出现，如果重复了就是 return false， 否则一直找到 sum 为 1 为止。

```Java
    public static boolean isHappyNum(int num) {
        Set<Integer> sumSet = new HashSet<>();
        while (num != 1 && !sumSet.contains(num)) {
            sumSet.add(num);
            num = calcNumber(num);
        }
        return num == 1;
    }

    private static int calcNumber(int num) {
        int sum = 0;
        int tmp;
        while (num > 0) {
            tmp = num % 10;
            sum += tmp * tmp;
            num = num / 10;
        }
        return sum;
    }
```

## 3、 两数之和

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

示例:

```
给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9
返回 [0, 1]
```

**思路**

```Java
    public static int[] getIndexes(int[] nums, int target) {
        int[] indexes = new int[2];
        if (nums == null || nums.length < 2) {
            return indexes;
        }
        Map<Integer, Integer> map = new HashMap<>();
        int tmp;
        for (int i = 0; i < nums.length; i++) {
            tmp = target - nums[i];
            if (map.containsKey(tmp)) {
                indexes[0] = i;
                indexes[1] = map.get(tmp);
                break;
            }
            map.put(nums[i], i);
        }
        return indexes;
    }
```
